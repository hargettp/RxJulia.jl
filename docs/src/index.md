# RxJulia Guide

This package is an implementation of the [ReactiveX](http://reactivex.io) reactive programming model in Julia.

Just like other libraries in the ReactiveX ecosystem, the basic [`Observable`](@ref) and `Subject` types exist (the latter is called [`Reactor`](@ref) here),  together with many operators for constructing new observables from existing ones.

`RxJulia` takes advantage of Julia's macro and type systems to create a domain-specific language (DSL) useful in reactive programming: see [Pipelines](@ref) for more details.

## Contents

```@contents
Depth = 3
```

## Pipelines

One area that is unique to RxJulia is the use of macros to create pipelines or chains of [`Reactor`](@ref) 
instances in code. Specifically the [`@rx`](@ref) macro makes this possible. 

```julia
events = @rx do
  observableFactory1
  reactorFactory1
  reactorFactory2
  # more....
end

for event in events
  # do something with the event.
end
```

Note that intermediate stages in a pipeline are [`Reactor`](@ref)s, capable of both being an [`Observer`](@ref) and an [`Observable`](@ref). Both the beginning and the end of the pipeline should be an [`Observable`](@ref) (of course, another
`Reactor` is fine too). A [`Reactor`](@ref) is the analogue of a [`Subject`](http://reactivex.io/documentation/subject.html) in the ReactiveX model.

When using `@rx`, a special observable, a [`Collector`](@ref), is added to the end of the chain, resulting in an object suitable for iteration. Iteration ends when a [`CompletedEvent`](@ref) or an [`ErrorEvent`](@ref) are encountered. Thus, it is possible to iterate over the events generated from the created pipeline.

```@example
using RxJulia # hide
evt = @rx(() -> 1)
```

Each statment inside the `@rx` block is actually an expression that should be a *factory* for creating an [`Observable`](@ref) or [`Reactor`](@ref), and each line subscribes to the events generated by the line above it, with [`subscribe!`](@ref). 

Fortunately, nearly any value will work as an [`Observable`](@ref): scalar values such as strings, numbers, booleans, symbols, etc., all result in an [`Observable`](@ref) that produces only a single value before completion. 

```@example
using RxJulia # hide
evts = @rx() do
  1
end
for evt in evts
  println("Event: $evt")
end
```

Values that are iterable will result in a stream of values passed to the downstream observers, completing when iteration ends.

```@example
using RxJulia # hide
evts = @rx() do
  [1 2 3]
end
for evt in evts
  println("Event: $evt")
end
```

Each pipeline created with [`@rx`](@ref) is itself an [`Observable`](@ref).

```@example
using RxJulia # hide
evts1 = @rx() do
  [1 2 3]
end

evts2 = @rx() do
  evts1
end

for evt in evts2
  println("Event: $evt")
end
```

## Kernel

### Functions

```@autodocs
Modules = [RxJulia]
Pages = ["kernel.jl"]
Order = [:function]
```

### Macros

```@autodocs
Modules = [RxJulia]
Pages = ["kernel.jl"]
Order = [:macro]
```

### Types

```@autodocs
Modules = [RxJulia]
Pages = ["kernel.jl"]
Order = [:type]
```

### Constants

```@autodocs
Modules = [RxJulia]
Pages = ["kernel.jl"]
Order = [:constant]
```

## Operators

### Functions

```@autodocs
Modules = [RxJulia]
Pages = ["operators.jl"]
Order = [:function]
```

### Macros

```@autodocs
Modules = [RxJulia]
Pages = ["operators.jl"]
Order = [:macro]
```

### Types

```@autodocs
Modules = [RxJulia]
Pages = ["operators.jl"]
Order = [:type]
```

### Constants

```@autodocs
Modules = [RxJulia]
Pages = ["operators.jl"]
Order = [:constant]