# RxJulia Guide

This package is an implementation of the [ReactiveX](http://reactivex.io) reactive programming model in Julia.

Just like other libraries in the ReactiveX ecosystem, the basic [`Observable`](@ref) and `Subject` types exist (the latter is called [`Reactor`](@ref) here),  together with many operators for constructing new observables from existing ones.

`RxJulia` takes advantage of Julia's macro and type systems to create a domain-specific language (DSL) useful in reactive programming: see [Pipelines](@ref) for more details.

## Contents

```@contents
Depth = 3
```

## Pipelines

One area that is unique to RxJulia is the use of macros to create pipelines or chains of [`Reactor`](@ref) 
instances in code. Specifically the [`@rx`](@ref) macro makes this possible. 

```julia
events = @rx do
  observableFactory1
  reactorFactory1
  reactorFactory2
  # more....
end

for event in events
  # do something with the event.
end
```

Note that intermediate stages in a pipeline are [`Reactor`](@ref)s, capable of both being an [`Observer`](@ref) and an [`Observable`](@ref). Both the beginning and the end of the pipeline should be an [`Observable`](@ref) (of course, another [`Reactor`](@ref) is fine too). A [`Reactor`](@ref) is the analogue of a [`Subject`](http://reactivex.io/documentation/subject.html) in the ReactiveX model.

When using `@rx`, a special observable, a [`Collector`](@ref), is added to the end of the chain, resulting in an object suitable for iteration. Iteration ends when a [`CompletedEvent`](@ref) or an [`ErrorEvent`](@ref) are encountered. Thus, it is possible to iterate over the events generated from the created pipeline.

```@example
using RxJulia # hide
evt = @rx(() -> 1)
```

Each statment inside the `@rx` block is actually an expression that should be a *factory* for creating an [`Observable`](@ref) or [`Reactor`](@ref), and each line subscribes to the events generated by the line above it, with [`subscribe!`](@ref). 

Fortunately, nearly any value will work as an [`Observable`](@ref): scalar values such as strings, numbers, booleans, symbols, etc., all result in an [`Observable`](@ref) that produces only a single value before completion. 

```@example
using RxJulia # hide
evts = @rx() do
  1
end
for evt in evts
  println("Event: $evt")
end
```

Values that are iterable will result in a stream of values passed to the downstream observers, completing when iteration ends.

```@example
using RxJulia # hide
evts = @rx() do
  [1 2 3]
end
for evt in evts
  println("Event: $evt")
end
```

Chaining occurs naturally within the pipeline (see [`detect`](@ref) for its meaning in this context):

```@example
using RxJulia # hide
evts = @rx() do
  [1, 2, 3, 4, 5, 6]
  detect(isodd)
end
println([evt for evt in evts])
```

Each pipeline created with [`@rx`](@ref) is itself an [`Observable`](@ref).

```@example
using RxJulia # hide
evts1 = @rx() do
  [1 2 3]
end

evts2 = @rx() do
  evts1
end

for evt in evts2
  println("Event: $evt")
end
```

## Kernel

The kernel is the fundamental implementation of the reactive pattern in Julia, independent of any operators that leverage the package's capabilities.

### Functions

```@autodocs
Modules = [RxJulia]
Pages = ["kernel.jl"]
Order = [:function]
```

### Macros

```@autodocs
Modules = [RxJulia]
Pages = ["kernel.jl"]
Order = [:macro]
```

### Types

```@autodocs
Modules = [RxJulia]
Pages = ["kernel.jl"]
Order = [:type]
```

### Constants

```@autodocs
Modules = [RxJulia]
Pages = ["kernel.jl"]
Order = [:constant]
```

## Operators

Operators are useful functions for producing [`Reactor`](@ref)s that receive events and decide whether to transform them or skip emitting values to downstream observers.

### Functions

```@autodocs
Modules = [RxJulia]
Pages = ["operators.jl"]
Order = [:function]
```

## Index

```@index
```